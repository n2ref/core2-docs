
Для обработки сохранения с форм модуля используется файл `ModAjax.php`, он находится в корне модуля.
Он должен наследоваться от класса `ajaxFunc`, который дает необходимую функциональность.

Файл содержит набор публичных методов, названия которых начинаются на `ax`. 
Такие методы вызываются если на странице с формы будет отправлен запрос на сохранение. 
У каждой формы есть название метода который должен выполниться для сохранения своего объекта.

Метод сохранения имеет входящий параметр `$data` в котором находятся сохраняемые и вспомогательные данные.
Все сохраняемые данные должны находиться в ключе `$data['control']`. 
К вспомогательным, по умолчанию, относятся `$data['class_id']`, `$data['class_refid']` в которых хранятся описание сохраняемого объекта. 
Могут быть и другие вспомогательные параметры.


#### Валидация

Для валидации сохраняемых данных в классе имеется метод `ajaxValidate`, он принимает переменную `$data`, 
список полей которые требуется валидировать и как именно их требуется валидировать.

```php
if ($this->ajaxValidate($data, [
    'form_field1' => 'req',
    'form_field2' => 'req,int',
    'form_field3' => 'email',
]) {
    return $this->response;
}
```

Возможные виды валидации:
1. req - параметр является обязательным для заполнения
2. int - параметр имеет тип int  
3. float - параметр имеет тип float
4. email - параметр содержит email


#### Очистка данных

Сохраняемые данные можно очистить от лишнего мусора. 
Например, от лишних пробелов в полях или от тегов в данных которые может отправить пользователь.
Для этого можно использовать встроенную функцию `$this->clearData()`
По умолчанию она именно это и делает, но можно передать список функций которые должны выполниться для каждого значения в данных `$data['control']` 


Пример
```php
$data['control'] = $this->clearData($data['control']);
```


#### Данные из сессий

При сохранении можно получать вспомогательные данные из сессии. 
Это дает возможность не хранить чувствительные или "секретные" данные на странице у пользователя.
Пр необходимости, такие данные ложатся в сессию при формировании формы и получаются в методе сохранения через метод `$this->getSessFormField()`.


Пример
```php
// Получение id сохраняемого объекта
$refid = $this->getSessFormField($data['class_id'], 'refid');

// Получение каких-то своих данных 
$example_data = $this->getSessFormField($data['class_id'], 'example_data');
```


#### Сохранение данных

Перед сохранением данных в базе есть возможность их редактировать, для этого допускается изменение переменных в массиве `$data['control']`.
Чтобы произошло сохранение все его ключи должны иметь такое же название полей как названия полей в таблице.   

Пример
```php
// если $refid пуст, то значит это создание новой записи, а не редактирование 
if (empty($refid)) {
    // заполнение полей данными по умолчанию
    $data['control']['date_created'] = date('Y-m-d H:i:s');
}
```

После того как данные будут готовы к сохранению, можно вызвать метод сохранения `$this->saveDataModel()`.
Это метод принимает модель таблицы, в которую производится сохранение и данные для сохранения.
В результате сохранения будет возвращен объект `\Zend_Db_Table_Row_Abstract` сохраненного объекта.  

Пример
```php
$order_row = $this->saveDataModel($this->modOrders->dataOrders, $order_data);
```


#### Ответ о результате сохранения

После сохранения данных или при возникновении ошибок метод сохранения обязан вернуть объект `$this->response`.
В этом находится данные с результатом выполнения. 

Для того чтобы вернуть ответ с успешным сохранением требуется предварительно выполнить метод `$this->done()`.
Дополнительно, при необходимости, можно выполнить какой-то js скрипт на странице, выполнив метод `$this->response->script()` 

Пример
```php
$this->response->script("CoreUI.notice.create('Сохранено');");
$this->done($data);
return $this->response;
```

Для того чтобы вернуть ответ с ошибкой требуется предварительно заполнить список ошибок и выполнить метод `$this->displayError()`

Пример
```php
$this->error[] = 'Текст ошибки которую увидит пользователь на странице формы';
$this->displayError($data);
return $this->response;
```


Пример файла целиком
```php
require_once DOC_ROOT . "core2/inc/ajax.func.php";


/**
 * 
 */
class ModAjax extends ajaxFunc {

    /**
     * Сохранение заказа 
     * @param array $data
     * @return xajaxResponse
     * @throws Exception
     */
    public function axSaveOrder(array $data): xajaxResponse {
        
        if ($this->ajaxValidate($data, [
            'form_field1' => 'req',
            'form_field2' => 'req,int',
            'form_field3' => 'req,email',
        ]) {
            return $this->response;
        }

        $data['control'] = $this->clearData($data['control']);
        
        
        $refid = $this->getSessFormField($data['class_id'], 'refid');

        $this->db->beginTransaction();
        try {
            if (empty($refid)) {
                $data['control']['date_created'] = date('Y-m-d H:i:s');
            }

            $order_row = $this->saveDataModel($this->modOrders->dataOrders, $order_data);


            $this->response->script("CoreUI.notice.create('Сохранено');");
            $this->response->script("load('index.php?module=orders&action=index&edit={$order_row->id}');");

            $this->db->commit();

        } catch (Exception $e) {
            $this->db->rollBack();
            $this->error[] = $e->getMessage();
        }

        $this->done($data);
        return $this->response;
    }
}
```